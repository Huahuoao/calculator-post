// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"com.huahuo/app/app/dao/model"
)

func newCalHistory(db *gorm.DB, opts ...gen.DOOption) calHistory {
	_calHistory := calHistory{}

	_calHistory.calHistoryDo.UseDB(db, opts...)
	_calHistory.calHistoryDo.UseModel(&model.CalHistory{})

	tableName := _calHistory.calHistoryDo.TableName()
	_calHistory.ALL = field.NewAsterisk(tableName)
	_calHistory.ID = field.NewInt32(tableName, "id")
	_calHistory.Data = field.NewString(tableName, "data")
	_calHistory.Result = field.NewString(tableName, "result")
	_calHistory.Time = field.NewString(tableName, "time")

	_calHistory.fillFieldMap()

	return _calHistory
}

type calHistory struct {
	calHistoryDo

	ALL    field.Asterisk
	ID     field.Int32
	Data   field.String
	Result field.String
	Time   field.String

	fieldMap map[string]field.Expr
}

func (c calHistory) Table(newTableName string) *calHistory {
	c.calHistoryDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c calHistory) As(alias string) *calHistory {
	c.calHistoryDo.DO = *(c.calHistoryDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *calHistory) updateTableName(table string) *calHistory {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewInt32(table, "id")
	c.Data = field.NewString(table, "data")
	c.Result = field.NewString(table, "result")
	c.Time = field.NewString(table, "time")

	c.fillFieldMap()

	return c
}

func (c *calHistory) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *calHistory) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 4)
	c.fieldMap["id"] = c.ID
	c.fieldMap["data"] = c.Data
	c.fieldMap["result"] = c.Result
	c.fieldMap["time"] = c.Time
}

func (c calHistory) clone(db *gorm.DB) calHistory {
	c.calHistoryDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c calHistory) replaceDB(db *gorm.DB) calHistory {
	c.calHistoryDo.ReplaceDB(db)
	return c
}

type calHistoryDo struct{ gen.DO }

type ICalHistoryDo interface {
	gen.SubQuery
	Debug() ICalHistoryDo
	WithContext(ctx context.Context) ICalHistoryDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ICalHistoryDo
	WriteDB() ICalHistoryDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ICalHistoryDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ICalHistoryDo
	Not(conds ...gen.Condition) ICalHistoryDo
	Or(conds ...gen.Condition) ICalHistoryDo
	Select(conds ...field.Expr) ICalHistoryDo
	Where(conds ...gen.Condition) ICalHistoryDo
	Order(conds ...field.Expr) ICalHistoryDo
	Distinct(cols ...field.Expr) ICalHistoryDo
	Omit(cols ...field.Expr) ICalHistoryDo
	Join(table schema.Tabler, on ...field.Expr) ICalHistoryDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ICalHistoryDo
	RightJoin(table schema.Tabler, on ...field.Expr) ICalHistoryDo
	Group(cols ...field.Expr) ICalHistoryDo
	Having(conds ...gen.Condition) ICalHistoryDo
	Limit(limit int) ICalHistoryDo
	Offset(offset int) ICalHistoryDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ICalHistoryDo
	Unscoped() ICalHistoryDo
	Create(values ...*model.CalHistory) error
	CreateInBatches(values []*model.CalHistory, batchSize int) error
	Save(values ...*model.CalHistory) error
	First() (*model.CalHistory, error)
	Take() (*model.CalHistory, error)
	Last() (*model.CalHistory, error)
	Find() ([]*model.CalHistory, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.CalHistory, err error)
	FindInBatches(result *[]*model.CalHistory, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.CalHistory) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ICalHistoryDo
	Assign(attrs ...field.AssignExpr) ICalHistoryDo
	Joins(fields ...field.RelationField) ICalHistoryDo
	Preload(fields ...field.RelationField) ICalHistoryDo
	FirstOrInit() (*model.CalHistory, error)
	FirstOrCreate() (*model.CalHistory, error)
	FindByPage(offset int, limit int) (result []*model.CalHistory, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ICalHistoryDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c calHistoryDo) Debug() ICalHistoryDo {
	return c.withDO(c.DO.Debug())
}

func (c calHistoryDo) WithContext(ctx context.Context) ICalHistoryDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c calHistoryDo) ReadDB() ICalHistoryDo {
	return c.Clauses(dbresolver.Read)
}

func (c calHistoryDo) WriteDB() ICalHistoryDo {
	return c.Clauses(dbresolver.Write)
}

func (c calHistoryDo) Session(config *gorm.Session) ICalHistoryDo {
	return c.withDO(c.DO.Session(config))
}

func (c calHistoryDo) Clauses(conds ...clause.Expression) ICalHistoryDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c calHistoryDo) Returning(value interface{}, columns ...string) ICalHistoryDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c calHistoryDo) Not(conds ...gen.Condition) ICalHistoryDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c calHistoryDo) Or(conds ...gen.Condition) ICalHistoryDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c calHistoryDo) Select(conds ...field.Expr) ICalHistoryDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c calHistoryDo) Where(conds ...gen.Condition) ICalHistoryDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c calHistoryDo) Order(conds ...field.Expr) ICalHistoryDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c calHistoryDo) Distinct(cols ...field.Expr) ICalHistoryDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c calHistoryDo) Omit(cols ...field.Expr) ICalHistoryDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c calHistoryDo) Join(table schema.Tabler, on ...field.Expr) ICalHistoryDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c calHistoryDo) LeftJoin(table schema.Tabler, on ...field.Expr) ICalHistoryDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c calHistoryDo) RightJoin(table schema.Tabler, on ...field.Expr) ICalHistoryDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c calHistoryDo) Group(cols ...field.Expr) ICalHistoryDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c calHistoryDo) Having(conds ...gen.Condition) ICalHistoryDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c calHistoryDo) Limit(limit int) ICalHistoryDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c calHistoryDo) Offset(offset int) ICalHistoryDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c calHistoryDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ICalHistoryDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c calHistoryDo) Unscoped() ICalHistoryDo {
	return c.withDO(c.DO.Unscoped())
}

func (c calHistoryDo) Create(values ...*model.CalHistory) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c calHistoryDo) CreateInBatches(values []*model.CalHistory, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c calHistoryDo) Save(values ...*model.CalHistory) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c calHistoryDo) First() (*model.CalHistory, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.CalHistory), nil
	}
}

func (c calHistoryDo) Take() (*model.CalHistory, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.CalHistory), nil
	}
}

func (c calHistoryDo) Last() (*model.CalHistory, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.CalHistory), nil
	}
}

func (c calHistoryDo) Find() ([]*model.CalHistory, error) {
	result, err := c.DO.Find()
	return result.([]*model.CalHistory), err
}

func (c calHistoryDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.CalHistory, err error) {
	buf := make([]*model.CalHistory, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c calHistoryDo) FindInBatches(result *[]*model.CalHistory, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c calHistoryDo) Attrs(attrs ...field.AssignExpr) ICalHistoryDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c calHistoryDo) Assign(attrs ...field.AssignExpr) ICalHistoryDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c calHistoryDo) Joins(fields ...field.RelationField) ICalHistoryDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c calHistoryDo) Preload(fields ...field.RelationField) ICalHistoryDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c calHistoryDo) FirstOrInit() (*model.CalHistory, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.CalHistory), nil
	}
}

func (c calHistoryDo) FirstOrCreate() (*model.CalHistory, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.CalHistory), nil
	}
}

func (c calHistoryDo) FindByPage(offset int, limit int) (result []*model.CalHistory, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c calHistoryDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c calHistoryDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c calHistoryDo) Delete(models ...*model.CalHistory) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *calHistoryDo) withDO(do gen.Dao) *calHistoryDo {
	c.DO = *do.(*gen.DO)
	return c
}
